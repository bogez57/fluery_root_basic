//- GENERATED CODE

R_D3D11_CmdGlobalKindInfo r_d3d11_g_cmd_global_kind_info_table[7] =
{
{0},
{sizeof(R_D3D11_CmdGlobals_Rect2D)},
{sizeof(R_D3D11_CmdGlobals_Sprite3D)},
{sizeof(R_D3D11_CmdGlobals_CompositeUnlit3D)},
{sizeof(R_D3D11_CmdGlobals_PointLight3D)},
{sizeof(R_D3D11_CmdGlobals_CompositeLit3D)},
{sizeof(R_D3D11_CmdGlobals_DebugLine3D)},
};

R_D3D11_ShaderPairKindInfo r_d3d11_g_shader_pair_kind_info_table[8] =
{
{0},
{Str8LitComp("r_d3d11_g_rect2d_shader_src"), r_d3d11_g_rect2d_shader_src, r_d3d11_g_rect2d_ilay_elements , ArrayCount(r_d3d11_g_rect2d_ilay_elements) },
{Str8LitComp("r_d3d11_g_sprite3d_shader_src"), r_d3d11_g_sprite3d_shader_src, r_d3d11_g_sprite3d_ilay_elements , ArrayCount(r_d3d11_g_sprite3d_ilay_elements) },
{Str8LitComp("r_d3d11_g_compositeunlit3d_shader_src"), r_d3d11_g_compositeunlit3d_shader_src,  0,  0},
{Str8LitComp("r_d3d11_g_pointlight3d_shader_src"), r_d3d11_g_pointlight3d_shader_src, r_d3d11_g_pointlight3d_ilay_elements , ArrayCount(r_d3d11_g_pointlight3d_ilay_elements) },
{Str8LitComp("r_d3d11_g_framebufferblit_shader_src"), r_d3d11_g_framebufferblit_shader_src,  0,  0},
{Str8LitComp("r_d3d11_g_compositelit3d_shader_src"), r_d3d11_g_compositelit3d_shader_src,  0,  0},
{Str8LitComp("r_d3d11_g_debugline3d_shader_src"), r_d3d11_g_debugline3d_shader_src, r_d3d11_g_debugline3d_ilay_elements , ArrayCount(r_d3d11_g_debugline3d_ilay_elements) },
};

read_only String8 r_d3d11_g_rect2d_shader_src =
Str8LitComp(""
"\n"
"//- rjf: resources\n"
"\n"
"cbuffer CmdGlobals : register(b0)\n"
"{\n"
" float2 viewport_size_px;\n"
" float opacity;\n"
" row_major float4x4 albedo_sample_channel_map;\n"
" float2 albedo_t2d_size_px;\n"
" row_major float3x3 xform;\n"
" float2 xform_scale;\n"
"}\n"
"\n"
"Texture2D albedo_t2d : register(t0);\n"
"SamplerState albedo_t2d_sampler : register(s0);\n"
"\n"
"//- rjf: cpu -> vshad -> pshad types\n"
"\n"
"struct CPU2Vertex\n"
"{\n"
" float4 dst_rect_px     : POS;\n"
" float4 src_rect_px     : TEX;\n"
" float4 color00         : COL0;\n"
" float4 color01         : COL1;\n"
" float4 color10         : COL2;\n"
" float4 color11         : COL3;\n"
" float4 corner_radii_px : CRAD;\n"
" float4 style_params    : STY; // x: border_thickness_px, y: softness_px, z: omit_texture, w: unused\n"
" uint vertex_id         : SV_VertexID;\n"
"};\n"
"\n"
"struct Vertex2Pixel\n"
"{\n"
" float4 position           : SV_POSITION;\n"
" float2 rect_half_size_px  : PSIZE;\n"
" float2 texcoord_pct       : TEX;\n"
" float2 cornercoord_pct    : COLC;\n"
" float4 color00            : COL0;\n"
" float4 color01            : COL1;\n"
" float4 color10            : COL2;\n"
" float4 color11            : COL3;\n"
" float corner_radius_px    : CRAD;\n"
" float border_thickness_px : BTHC;\n"
" float softness_px         : SFT;\n"
" float omit_texture        : OTX;\n"
"};\n"
"\n"
"//- rjf: helpers\n"
"\n"
"float RectSDF(float2 sample_pos, float2 rect_half_size, float r)\n"
"{\n"
" return length(max(abs(sample_pos) - rect_half_size + r, 0.0)) - r;\n"
"}\n"
"\n"
"//- rjf: vertex shader\n"
"\n"
"Vertex2Pixel\n"
"vs_main(CPU2Vertex cpu2vertex)\n"
"{\n"
" //- rjf: unpack & xform rectangle src/dst vertices\n"
" float2 dst_p0_px  = cpu2vertex.dst_rect_px.xy;\n"
" float2 dst_p1_px  = cpu2vertex.dst_rect_px.zw;\n"
" float2 src_p0_px  = cpu2vertex.src_rect_px.xy;\n"
" float2 src_p1_px  = cpu2vertex.src_rect_px.zw;\n"
" float2 dst_size_px = abs(dst_p1_px - dst_p0_px);\n"
" \n"
" //- rjf: unpack style params\n"
" float border_thickness_px = cpu2vertex.style_params.x;\n"
" float softness_px         = cpu2vertex.style_params.y;\n"
" float omit_texture        = cpu2vertex.style_params.z;\n"
" \n"
" //- rjf: prep per-vertex arrays to sample from (p: position, t: texcoord, c: colorcoord, r: cornerradius)\n"
" float2 dst_p_verts_px[] =\n"
" {\n"
"  mul(xform, float3(dst_p0_px.x, dst_p1_px.y, 1)).xy * float2(1, -1) + float2(0, viewport_size_px.y),\n"
"  mul(xform, float3(dst_p0_px.x, dst_p0_px.y, 1)).xy * float2(1, -1) + float2(0, viewport_size_px.y),\n"
"  mul(xform, float3(dst_p1_px.x, dst_p1_px.y, 1)).xy * float2(1, -1) + float2(0, viewport_size_px.y),\n"
"  mul(xform, float3(dst_p1_px.x, dst_p0_px.y, 1)).xy * float2(1, -1) + float2(0, viewport_size_px.y),\n"
" };\n"
" float2 src_p_verts_pct[] =\n"
" {\n"
"  float2(src_p0_px.x/albedo_t2d_size_px.x, src_p1_px.y/albedo_t2d_size_px.y),\n"
"  float2(src_p0_px.x/albedo_t2d_size_px.x, src_p0_px.y/albedo_t2d_size_px.y),\n"
"  float2(src_p1_px.x/albedo_t2d_size_px.x, src_p1_px.y/albedo_t2d_size_px.y),\n"
"  float2(src_p1_px.x/albedo_t2d_size_px.x, src_p0_px.y/albedo_t2d_size_px.y),\n"
" };\n"
" float2 dst_c_verts_pct[] =\n"
" {\n"
"  float2(0, 1),\n"
"  float2(0, 0),\n"
"  float2(1, 1),\n"
"  float2(1, 0),\n"
" };\n"
" float dst_r_verts_px[] =\n"
" {\n"
"  cpu2vertex.corner_radii_px.y,\n"
"  cpu2vertex.corner_radii_px.x,\n"
"  cpu2vertex.corner_radii_px.w,\n"
"  cpu2vertex.corner_radii_px.z,\n"
" };\n"
" \n"
" // rjf: fill vertex -> pixel data\n"
" Vertex2Pixel vertex2pixel;\n"
" {\n"
"  vertex2pixel.position.x           = 2 * dst_p_verts_px[cpu2vertex.vertex_id].x / viewport_size_px.x - 1.f;\n"
"  vertex2pixel.position.y           = 2 * dst_p_verts_px[cpu2vertex.vertex_id].y / viewport_size_px.y - 1.f;\n"
"  vertex2pixel.position.z           = 0.f;\n"
"  vertex2pixel.position.w           = 1.f;\n"
"  vertex2pixel.rect_half_size_px    = dst_size_px/2 * xform_scale;\n"
"  vertex2pixel.texcoord_pct         = src_p_verts_pct[cpu2vertex.vertex_id];\n"
"  vertex2pixel.cornercoord_pct      = dst_c_verts_pct[cpu2vertex.vertex_id];\n"
"  vertex2pixel.color00              = cpu2vertex.color00;\n"
"  vertex2pixel.color01              = cpu2vertex.color01;\n"
"  vertex2pixel.color10              = cpu2vertex.color10;\n"
"  vertex2pixel.color11              = cpu2vertex.color11;\n"
"  vertex2pixel.corner_radius_px     = dst_r_verts_px[cpu2vertex.vertex_id];\n"
"  vertex2pixel.border_thickness_px  = border_thickness_px;\n"
"  vertex2pixel.softness_px          = softness_px;\n"
"  vertex2pixel.omit_texture         = omit_texture;\n"
" }\n"
" return vertex2pixel;\n"
"}\n"
"\n"
"//- rjf: pixel shader\n"
"\n"
"float4\n"
"ps_main(Vertex2Pixel vertex2pixel) : SV_TARGET\n"
"{\n"
" // rjf: blend corner colors to produce final tint\n"
" float4 top_color   = (1-vertex2pixel.cornercoord_pct.x)*vertex2pixel.color00 + (vertex2pixel.cornercoord_pct.x)*vertex2pixel.color10;\n"
" float4 bot_color   = (1-vertex2pixel.cornercoord_pct.x)*vertex2pixel.color01 + (vertex2pixel.cornercoord_pct.x)*vertex2pixel.color11;\n"
" float4 tint        = (1-vertex2pixel.cornercoord_pct.y)*top_color + (vertex2pixel.cornercoord_pct.y)*bot_color;\n"
" \n"
" // rjf: sample albedo\n"
" float4 albedo_sample = float4(1, 1, 1, 1);\n"
" if(vertex2pixel.omit_texture < 1)\n"
" {\n"
"  albedo_sample = mul(albedo_t2d.Sample(albedo_t2d_sampler, vertex2pixel.texcoord_pct), albedo_sample_channel_map);\n"
" }\n"
" \n"
" // rjf: determine SDF sample position\n"
" float2 sdf_sample_pos = float2((2*vertex2pixel.cornercoord_pct.x-1)*vertex2pixel.rect_half_size_px.x,\n"
"                                (2*vertex2pixel.cornercoord_pct.y-1)*vertex2pixel.rect_half_size_px.y);\n"
" \n"
" // rjf: sample for corners\n"
" float corner_sdf_s = RectSDF(sdf_sample_pos,\n"
"                              vertex2pixel.rect_half_size_px - float2(vertex2pixel.softness_px*2.f, vertex2pixel.softness_px*2.f),\n"
"                              vertex2pixel.corner_radius_px);\n"
" float corner_sdf_t = 1-smoothstep(0, 2*vertex2pixel.softness_px, corner_sdf_s);\n"
" \n"
" // rjf: sample for borders\n"
" float border_sdf_s = RectSDF(sdf_sample_pos,\n"
"                              vertex2pixel.rect_half_size_px - float2(vertex2pixel.softness_px*2.f, vertex2pixel.softness_px*2.f) - vertex2pixel.border_thickness_px,\n"
"                              max(vertex2pixel.corner_radius_px-vertex2pixel.border_thickness_px, 0));\n"
" float border_sdf_t = smoothstep(0, 2*vertex2pixel.softness_px, border_sdf_s);\n"
" if(vertex2pixel.border_thickness_px == 0)\n"
" {\n"
"  border_sdf_t = 1;\n"
" }\n"
" \n"
" // rjf: form+return final color\n"
" float4 final_color = albedo_sample;\n"
" final_color *= tint;\n"
" final_color *= opacity;\n"
" final_color *= corner_sdf_t;\n"
" final_color *= border_sdf_t;\n"
" return final_color;\n"
"}\n"
""
);

read_only String8 r_d3d11_g_sprite3d_shader_src =
Str8LitComp(""
"\n"
"//- rjf: resources\n"
"\n"
"cbuffer CmdGlobals : register(b0)\n"
"{\n"
" float4x4 xform;\n"
" row_major float4x4 albedo_sample_channel_map;\n"
" float2 albedo_t2d_size_px;\n"
" float alpha_test_min;\n"
"}\n"
"\n"
"Texture2D albedo_t2d : register(t0);\n"
"SamplerState albedo_t2d_sampler : register(s0);\n"
"\n"
"//- rjf: cpu -> vshad -> pshad types\n"
"\n"
"struct CPU2Vertex\n"
"{\n"
" float4 pos_rs          : POS;\n"
" float4x4 xform         : XFM;\n"
" float4 src_rect_px     : TEX;\n"
" float4 color00         : COL0;\n"
" float4 color01         : COL1;\n"
" float4 color10         : COL2;\n"
" float4 color11         : COL3;\n"
" float omit_texture     : OTX;\n"
" float shear            : SHR;\n"
" float2 _unused_        : PAD;\n"
" uint vertex_id         : SV_VertexID;\n"
"};\n"
"\n"
"struct Vertex2Pixel\n"
"{\n"
" float4 pos_rs          : SV_POSITION;\n"
" float2 texcoord_px     : TEX;\n"
" float4 color00         : COL0;\n"
" float4 color01         : COL1;\n"
" float4 color10         : COL2;\n"
" float4 color11         : COL3;\n"
" float2 colorcoord_pct  : TEX1;\n"
" float omit_texture     : OTX;\n"
"};\n"
"\n"
"//- rjf: vertex shader\n"
"\n"
"Vertex2Pixel\n"
"vs_main(CPU2Vertex cpu2vertex)\n"
"{\n"
" //- rjf: unpack instance data\n"
" float2 src_p0_px  = cpu2vertex.src_rect_px.xy;\n"
" float2 src_p1_px  = cpu2vertex.src_rect_px.zw;\n"
" \n"
" //- rjf: bundle per-vertex attribute arrays, to sample from via vertex ID\n"
" float3 dst_p_verts_rs[] =\n"
" {\n"
"  mul(cpu2vertex.xform, float4(-0.5f+cpu2vertex.shear, -0.5f, 0.f, 1.f)).xyz,\n"
"  mul(cpu2vertex.xform, float4(-0.5f, +0.5f, 0.f, 1.f)).xyz,\n"
"  mul(cpu2vertex.xform, float4(+0.5f+cpu2vertex.shear, -0.5f, 0.f, 1.f)).xyz,\n"
"  mul(cpu2vertex.xform, float4(+0.5f, +0.5f, 0.f, 1.f)).xyz,\n"
" };\n"
" float2 src_p_verts_px[] =\n"
" {\n"
"  float2(src_p0_px.x, src_p0_px.y),\n"
"  float2(src_p0_px.x, src_p1_px.y),\n"
"  float2(src_p1_px.x, src_p0_px.y),\n"
"  float2(src_p1_px.x, src_p1_px.y),\n"
" };\n"
" float2 dst_c_verts_pct[] =\n"
" {\n"
"  float2(0, 1),\n"
"  float2(0, 0),\n"
"  float2(1, 1),\n"
"  float2(1, 0),\n"
" };\n"
" \n"
" //- rjf: produce final vertex position\n"
" float4 pos_rs = cpu2vertex.pos_rs;\n"
" pos_rs.x += dst_p_verts_rs[cpu2vertex.vertex_id].x;\n"
" pos_rs.y += dst_p_verts_rs[cpu2vertex.vertex_id].y;\n"
" pos_rs.z += dst_p_verts_rs[cpu2vertex.vertex_id].z;\n"
" pos_rs = mul(xform, pos_rs);\n"
" \n"
" //- rjf: produce final vertex texcoord\n"
" float2 texcoord_px = src_p_verts_px[cpu2vertex.vertex_id];\n"
" \n"
" //- rjf: produce final vertex colorcoord\n"
" float2 colorcoord_pct = dst_c_verts_pct[cpu2vertex.vertex_id];\n"
" \n"
" //- rjf: fill vertex -> pixel data\n"
" Vertex2Pixel vertex2pixel;\n"
" {\n"
"  vertex2pixel.pos_rs         = pos_rs;\n"
"  vertex2pixel.texcoord_px    = texcoord_px;\n"
"  vertex2pixel.color00        = cpu2vertex.color00;\n"
"  vertex2pixel.color01        = cpu2vertex.color01;\n"
"  vertex2pixel.color10        = cpu2vertex.color10;\n"
"  vertex2pixel.color11        = cpu2vertex.color11;\n"
"  vertex2pixel.colorcoord_pct = colorcoord_pct;\n"
"  vertex2pixel.omit_texture   = cpu2vertex.omit_texture.x;\n"
" }\n"
" return vertex2pixel;\n"
"}\n"
"\n"
"//- rjf: pixel shader\n"
"\n"
"float4\n"
"ps_main(Vertex2Pixel vertex2pixel) : SV_TARGET\n"
"{\n"
" // rjf: blend corner colors to get final pixel tint\n"
" float4 top_color   = (1-vertex2pixel.colorcoord_pct.x)*vertex2pixel.color00 + (vertex2pixel.colorcoord_pct.x)*vertex2pixel.color10;\n"
" float4 bot_color   = (1-vertex2pixel.colorcoord_pct.x)*vertex2pixel.color01 + (vertex2pixel.colorcoord_pct.x)*vertex2pixel.color11;\n"
" float4 tint        = (1-vertex2pixel.colorcoord_pct.y)*top_color + (vertex2pixel.colorcoord_pct.y)*bot_color;\n"
" \n"
" // rjf: sample albedo texture\n"
" float4 albedo_sample = float4(1, 1, 1, 1);\n"
" if(vertex2pixel.omit_texture < 1)\n"
" {\n"
"  float2 texcoord_px = floor(vertex2pixel.texcoord_px) + min(frac(vertex2pixel.texcoord_px)/fwidth(vertex2pixel.texcoord_px), 1.f) - 0.5f;\n"
"  albedo_sample = mul(albedo_t2d.Sample(albedo_t2d_sampler, texcoord_px/albedo_t2d_size_px), albedo_sample_channel_map);\n"
"  albedo_sample.xyz /= albedo_sample.w;\n"
" }\n"
" \n"
" // rjf: alpha test\n"
" if(albedo_sample.w < alpha_test_min)\n"
" {\n"
"  discard;\n"
" }\n"
" \n"
" // rjf: form+return final color\n"
" float4 final_color = albedo_sample;\n"
" final_color *= tint;\n"
" return final_color;\n"
"}\n"
""
);

read_only String8 r_d3d11_g_compositeunlit3d_shader_src =
Str8LitComp(""
"\n"
"//- rjf: resources\n"
"\n"
"cbuffer CmdGlobals : register(b0)\n"
"{\n"
" float4x4 inverse_view_projection;\n"
" float4x4 shadowmap_view_projection;\n"
" float4 fog_color;\n"
" float pct_fog_per_unit;\n"
" float near_z;\n"
" float far_z;\n"
"}\n"
"\n"
"Texture2D albedo_t2d    : register(t0);\n"
"Texture2D depth_t2d     : register(t1);\n"
"Texture2D shadowmap_t2d : register(t2);\n"
"SamplerState albedo_t2d_sampler    : register(s0);\n"
"SamplerState depth_t2d_sampler     : register(s1);\n"
"SamplerState shadowmap_t2d_sampler : register(s2);\n"
"\n"
"//- rjf: cpu -> vshad -> pshad types\n"
"\n"
"struct CPU2Vertex\n"
"{\n"
" uint vertex_id         : SV_VertexID;\n"
"};\n"
"\n"
"struct Vertex2Pixel\n"
"{\n"
" float4 pos_rs          : SV_POSITION;\n"
" float2 texcoord_pct    : TEX;\n"
"};\n"
"\n"
"//- rjf: vertex shader\n"
"\n"
"Vertex2Pixel\n"
"vs_main(CPU2Vertex cpu2vertex)\n"
"{\n"
" float2 vertices[] =\n"
" {\n"
"  float2(-1, -1),\n"
"  float2(-1, +1),\n"
"  float2(+1, -1),\n"
"  float2(+1, +1),\n"
" };\n"
" float2 vertex = vertices[cpu2vertex.vertex_id];\n"
" Vertex2Pixel vertex2pixel;\n"
" {\n"
"  vertex2pixel.pos_rs = float4(vertex.x, vertex.y, 0, 1);\n"
"  vertex2pixel.texcoord_pct = float2((vertex.x+1)/2, (-vertex.y+1)/2);\n"
" }\n"
" return vertex2pixel;\n"
"}\n"
"\n"
"//- rjf: pixel shader\n"
"\n"
"float4\n"
"ps_main(Vertex2Pixel vertex2pixel) : SV_TARGET\n"
"{\n"
" // rjf: sample albedo buffer\n"
" float4 albedo = albedo_t2d.Sample(albedo_t2d_sampler, vertex2pixel.texcoord_pct);\n"
" \n"
" // rjf: sample depth buffer\n"
" float depth = depth_t2d.Sample(depth_t2d_sampler, vertex2pixel.texcoord_pct).r;\n"
" \n"
" // rjf: clip-space -> world-space\n"
" float4 world_space_pos = float4(0, 0, 0, 0);\n"
" {\n"
"  float4 clip_space_pos = float4(2*vertex2pixel.texcoord_pct.x-1,\n"
"                                 -(2*vertex2pixel.texcoord_pct.y-1),\n"
"                                 depth,\n"
"                                 1);\n"
"  world_space_pos = mul(inverse_view_projection, clip_space_pos);\n"
"  world_space_pos /= world_space_pos.w;\n"
" }\n"
" \n"
" // rjf: world-space -> shadowmap-clip-space\n"
" float4 shadowmap_clip_space_pos = mul(shadowmap_view_projection, world_space_pos);\n"
" shadowmap_clip_space_pos /= shadowmap_clip_space_pos.w;\n"
" \n"
" // rjf: sample shadow map\n"
" float shadow = 0;\n"
" {\n"
"  float2 shadowmap_sample_pos_center = float2((shadowmap_clip_space_pos.x+1)/2, 1-(shadowmap_clip_space_pos.y+1)/2);\n"
"  float shadow_sum = 0;\n"
"  float shadow_count = 0;\n"
"  for(int x = -2; x <= 2; x += 1)\n"
"  {\n"
"   for(int y = -2; y <= 2; y += 1)\n"
"   {\n"
"    float shadowmap_sample = shadowmap_t2d.Sample(shadowmap_t2d_sampler, shadowmap_sample_pos_center + float2(x/750.f, y/750.f)).r;\n"
"    float difference_from_real_depth = shadowmap_clip_space_pos.z-shadowmap_sample;\n"
"    if(difference_from_real_depth > 0.003f)\n"
"    {\n"
"     shadow_sum += 1.f;\n"
"    }\n"
"    shadow_count += 1;\n"
"   }\n"
"  }\n"
"  shadow = shadow_sum/shadow_count;\n"
" }\n"
" \n"
" // rjf: albedo -> shaded\n"
" float4 shaded = float4(albedo.x * (1 - shadow*0.5),\n"
"                        albedo.y * (1 - shadow*0.5),\n"
"                        albedo.z * (1 - shadow*0.5),\n"
"                        albedo.w * (1 - shadow*0.5));\n"
" \n"
" // rjf: form color\n"
" float4 final_color = shaded;\n"
" return final_color;\n"
"}\n"
""
);

read_only String8 r_d3d11_g_pointlight3d_shader_src =
Str8LitComp(""
"\n"
"//- rjf: resources\n"
"\n"
"cbuffer CmdGlobals : register(b0)\n"
"{\n"
" float4x4 xform;\n"
" float4x4 inverse_view_projection;\n"
"}\n"
"\n"
"Texture2D depth_t2d : register(t0);\n"
"SamplerState depth_t2d_sampler : register(s0);\n"
"\n"
"//- rjf: cpu -> vshad -> pshad types\n"
"\n"
"struct CPU2Vertex\n"
"{\n"
" float3 vtx_pos        : VTX;\n"
" float4 center_pos     : POS;\n"
" float4 color          : COL;\n"
" float4 params         : PRM;\n"
"};\n"
"\n"
"struct Vertex2Pixel\n"
"{\n"
" float4 pos             : SV_POSITION;\n"
" float4 pos_clip        : CLP;\n"
" float4 ws_pos          : VTX;\n"
" float4 center_pos      : POS;\n"
" float4 color           : COL;\n"
"};\n"
"\n"
"//- rjf: vertex shader\n"
"\n"
"Vertex2Pixel\n"
"vs_main(CPU2Vertex c2v)\n"
"{\n"
" Vertex2Pixel v2p;\n"
" {\n"
"  v2p.ws_pos = float4(c2v.vtx_pos.x*c2v.center_pos.w + c2v.center_pos.x,\n"
"                      c2v.vtx_pos.y*c2v.center_pos.w + c2v.center_pos.y,\n"
"                      c2v.vtx_pos.z*c2v.center_pos.w + c2v.center_pos.z,\n"
"                      1.f);\n"
"  v2p.pos = mul(xform, v2p.ws_pos);\n"
"  v2p.pos_clip = v2p.pos;\n"
"  v2p.center_pos = c2v.center_pos;\n"
"  v2p.color = c2v.color;\n"
" }\n"
" return v2p;\n"
"}\n"
"\n"
"//- rjf: pixel shader\n"
"\n"
"float4\n"
"ps_main(Vertex2Pixel v2p) : SV_TARGET\n"
"{\n"
" // rjf: build texcoord\n"
" float2 texcoord = float2((v2p.pos_clip.x/v2p.pos_clip.w+1)/2, 1-(v2p.pos_clip.y/v2p.pos_clip.w+1)/2);\n"
" \n"
" // rjf: sample depth buffer\n"
" float depth = depth_t2d.Sample(depth_t2d_sampler, texcoord).r;\n"
" \n"
" // rjf: this pixel's depth > sample -> discard\n"
" if(v2p.pos.z > depth)\n"
" {\n"
"  discard;\n"
" }\n"
" \n"
" // rjf: clip-space -> world-space\n"
" float4 world_space_pos = float4(0, 0, 0, 0);\n"
" {\n"
"  float4 clip_space_pos = float4(v2p.pos_clip.x/v2p.pos_clip.w,\n"
"                                 v2p.pos_clip.y/v2p.pos_clip.w,\n"
"                                 depth,\n"
"                                 1);\n"
"  world_space_pos = mul(inverse_view_projection, clip_space_pos);\n"
"  world_space_pos /= world_space_pos.w;\n"
" }\n"
" \n"
" // rjf: world-space * light-center * radius -> light factor\n"
" float light_factor = 0.f;\n"
" {\n"
"  float radius = v2p.center_pos.w;\n"
"  float3 p2l = world_space_pos.xyz - v2p.center_pos.xyz;\n"
"  light_factor = 1-dot(p2l, p2l)/(radius*radius);\n"
" }\n"
" \n"
" // rjf: build final color & export\n"
" float4 color = v2p.color * light_factor;\n"
" return color;\n"
"}\n"
""
);

read_only String8 r_d3d11_g_framebufferblit_shader_src =
Str8LitComp(""
"\n"
"//- rjf: resources\n"
"\n"
"Texture2D src_t2d    : register(t0);\n"
"SamplerState src_t2d_sampler    : register(s0);\n"
"\n"
"//- rjf: cpu -> vshad -> pshad types\n"
"\n"
"struct CPU2Vertex\n"
"{\n"
" uint vertex_id         : SV_VertexID;\n"
"};\n"
"\n"
"struct Vertex2Pixel\n"
"{\n"
" float4 pos_rs          : SV_POSITION;\n"
" float2 texcoord_pct    : TEX;\n"
"};\n"
"\n"
"//- rjf: vertex shader\n"
"\n"
"Vertex2Pixel\n"
"vs_main(CPU2Vertex cpu2vertex)\n"
"{\n"
" float2 vertices[] =\n"
" {\n"
"  float2(-1, -1),\n"
"  float2(-1, +1),\n"
"  float2(+1, -1),\n"
"  float2(+1, +1),\n"
" };\n"
" float2 vertex = vertices[cpu2vertex.vertex_id];\n"
" Vertex2Pixel vertex2pixel;\n"
" {\n"
"  vertex2pixel.pos_rs = float4(vertex.x, vertex.y, 0, 1);\n"
"  vertex2pixel.texcoord_pct = float2((vertex.x+1)/2, (-vertex.y+1)/2);\n"
" }\n"
" return vertex2pixel;\n"
"}\n"
"\n"
"//- rjf: pixel shader\n"
"\n"
"float4\n"
"ps_main(Vertex2Pixel vertex2pixel) : SV_TARGET\n"
"{\n"
" float4 color = src_t2d.Sample(src_t2d_sampler, vertex2pixel.texcoord_pct);\n"
" return color;\n"
"}\n"
""
);

read_only String8 r_d3d11_g_compositelit3d_shader_src =
Str8LitComp(""
"\n"
"//- rjf: resources\n"
"\n"
"cbuffer CmdGlobals : register(b0)\n"
"{\n"
" float4x4 inverse_view_projection;\n"
" float4 fog_color;\n"
" float pct_fog_per_unit;\n"
" float near_z;\n"
" float far_z;\n"
"}\n"
"\n"
"Texture2D albedo_t2d    : register(t0);\n"
"Texture2D depth_t2d     : register(t1);\n"
"SamplerState albedo_t2d_sampler    : register(s0);\n"
"SamplerState depth_t2d_sampler     : register(s1);\n"
"\n"
"//- rjf: cpu -> vshad -> pshad types\n"
"\n"
"struct CPU2Vertex\n"
"{\n"
" uint vertex_id         : SV_VertexID;\n"
"};\n"
"\n"
"struct Vertex2Pixel\n"
"{\n"
" float4 pos_rs          : SV_POSITION;\n"
" float2 texcoord_pct    : TEX;\n"
"};\n"
"\n"
"//- rjf: noise functions (adapted from https://www.shadertoy.com/view/lsf3WH)\n"
"\n"
"float\n"
"HashFromInt2(int2 p)\n"
"{\n"
" // 2D -> 1D\n"
" int n = p.x*3 + p.y*113;\n"
" \n"
" // 1D hash by Hugo Elias\n"
"	n = (n << 13) ^ n;\n"
" n = n * (n * n * 15731 + 789221) + 1376312589;\n"
" return -1.0+2.0*float(n & 0x0fffffff)/float(0x0fffffff);\n"
"}\n"
"\n"
"float NoiseFromFloat2(float2 p)\n"
"{\n"
" int2 i = int2(floor(p));\n"
" float2 f = frac(p);\n"
" float2 u = f*f*(3.0-2.0*f);\n"
" return lerp(lerp(HashFromInt2(i + int2(0, 0)), \n"
"                  HashFromInt2(i + int2(1, 0)), u.x),\n"
"             lerp(HashFromInt2(i + int2(0, 1)), \n"
"                  HashFromInt2(i + int2(1, 1)), u.x), u.y);\n"
"}\n"
"\n"
"//- rjf: vertex shader\n"
"\n"
"Vertex2Pixel\n"
"vs_main(CPU2Vertex cpu2vertex)\n"
"{\n"
" float2 vertices[] =\n"
" {\n"
"  float2(-1, -1),\n"
"  float2(-1, +1),\n"
"  float2(+1, -1),\n"
"  float2(+1, +1),\n"
" };\n"
" float2 vertex = vertices[cpu2vertex.vertex_id];\n"
" Vertex2Pixel vertex2pixel;\n"
" {\n"
"  vertex2pixel.pos_rs = float4(vertex.x, vertex.y, 0, 1);\n"
"  vertex2pixel.texcoord_pct = float2((vertex.x+1)/2, (-vertex.y+1)/2);\n"
" }\n"
" return vertex2pixel;\n"
"}\n"
"\n"
"//- rjf: pixel shader\n"
"\n"
"float4\n"
"ps_main(Vertex2Pixel vertex2pixel) : SV_TARGET\n"
"{\n"
" // rjf: sample albedo buffer\n"
" float4 albedo = albedo_t2d.Sample(albedo_t2d_sampler, vertex2pixel.texcoord_pct);\n"
" \n"
" // rjf: sample depth buffer\n"
" float depth = depth_t2d.Sample(depth_t2d_sampler, vertex2pixel.texcoord_pct).r;\n"
" \n"
" // rjf: clip-space -> world-space\n"
" float4 world_space_pos = float4(0, 0, 0, 0);\n"
" {\n"
"  float4 clip_space_pos = float4(2*vertex2pixel.texcoord_pct.x-1,\n"
"                                 -(2*vertex2pixel.texcoord_pct.y-1),\n"
"                                 depth,\n"
"                                 1);\n"
"  world_space_pos = mul(inverse_view_projection, clip_space_pos);\n"
"  world_space_pos /= world_space_pos.w;\n"
" }\n"
" \n"
" // rjf: generate world-space noise\n"
" float world_space_noise = 0;\n"
" {\n"
"  float2 noisecoord = world_space_pos.xy;\n"
"  float2x2 m = float2x2(1.6f, 1.2f, -1.2f, 1.6f);\n"
"  world_space_noise = 0.5000f*NoiseFromFloat2(noisecoord);\n"
"  noisecoord = mul(m, noisecoord);\n"
"  world_space_noise += 0.2500f*NoiseFromFloat2(noisecoord);\n"
"  noisecoord = mul(m, noisecoord);\n"
"  world_space_noise += 0.1250f*NoiseFromFloat2(noisecoord);\n"
"  noisecoord = mul(m, noisecoord);\n"
"  world_space_noise += 0.0625f*NoiseFromFloat2(noisecoord);\n"
"  noisecoord = mul(m, noisecoord);\n"
"  world_space_noise = (world_space_noise+1)/2;\n"
" }\n"
" \n"
" // rjf: depth -> linearized depth -> fog_pct\n"
" float linear_depth = (near_z*far_z) / (far_z + depth*(near_z-far_z));\n"
" float fog_pct = saturate(pct_fog_per_unit*linear_depth);\n"
" \n"
" // rjf: albedo -> fogged\n"
" float4 fogged = float4(albedo.x + (fog_color.x-albedo.x)*fog_pct,\n"
"                        albedo.y + (fog_color.y-albedo.y)*fog_pct,\n"
"                        albedo.z + (fog_color.z-albedo.z)*fog_pct,\n"
"                        albedo.w + (fog_color.w-albedo.w)*fog_pct);\n"
" \n"
" // rjf: form color\n"
" float4 final_color = fogged;\n"
" return final_color;\n"
"}\n"
""
);

read_only String8 r_d3d11_g_debugline3d_shader_src =
Str8LitComp(""
"\n"
"//- rjf: resources\n"
"\n"
"cbuffer CmdGlobals : register(b0)\n"
"{\n"
" float4x4 xform;\n"
"}\n"
"\n"
"//- rjf: cpu -> vshad -> pshad types\n"
"\n"
"struct CPU2Vertex\n"
"{\n"
" float4 p0_rs   : POS0;\n"
" float4 p1_rs   : POS1;\n"
" float4 c0      : COL0;\n"
" float4 c1      : COL1;\n"
" uint vertex_id : SV_VertexID;\n"
"};\n"
"\n"
"struct Vertex2Pixel\n"
"{\n"
" float4 pos_rs : SV_POSITION;\n"
" float4 color  : COL;\n"
"};\n"
"\n"
"//- rjf: vertex shader\n"
"\n"
"Vertex2Pixel\n"
"vs_main(CPU2Vertex cpu2vertex)\n"
"{\n"
" float4 p0_rs = cpu2vertex.p0_rs;\n"
" float4 p1_rs = cpu2vertex.p1_rs;\n"
" float4 c0 = cpu2vertex.c0;\n"
" float4 c1 = cpu2vertex.c1;\n"
" float4 verts_pos[] =\n"
" {\n"
"  mul(xform, p0_rs),\n"
"  mul(xform, p1_rs),\n"
" };\n"
" float4 verts_col[] =\n"
" {\n"
"  c0,\n"
"  c1,\n"
" };\n"
" Vertex2Pixel vertex2pixel;\n"
" {\n"
"  vertex2pixel.pos_rs = verts_pos[cpu2vertex.vertex_id];\n"
"  vertex2pixel.color  = verts_col[cpu2vertex.vertex_id];\n"
" }\n"
" return vertex2pixel;\n"
"}\n"
"\n"
"//- rjf: pixel shader\n"
"\n"
"float4\n"
"ps_main(Vertex2Pixel vertex2pixel) : SV_TARGET\n"
"{\n"
" return vertex2pixel.color;\n"
"}\n"
"\n"
""
);

